// get the curent documentvar doc_ref = doc = app.activeDocument;// get current artboard and save width/height for use in sizing the guillochevar currentArtboard = doc_ref.artboards[doc_ref.artboards.getActiveArtboardIndex()],    size = {      x: Math.floor(Math.abs( currentArtboard.artboardRect[2] )),       y: Math.floor(Math.abs( currentArtboard.artboardRect[3] ))    },    halfSize = {x: size.x / 2, y: size.y / 2};// CONFIG ZONE - PLAY AROUND// array of "good looking" guilloche keys. script chooses one at randomvar keys = [50, 71, 75, 76, 100, 112, 152, 200, 269, 270, 279, 284, 292, 295, 300],    guilloche_key = keys[ Math.floor( Math.random() * keys.length ) ];// Guilloche rendering opts - have fun    var factor = 0.426;var guillocheOptions = {  majorR: (size.x - 250),	minorR: (size.x - 250)  * factor,	angleMultiplier: guilloche_key,  radiusEffectConstant: 250,  steps: 1500,  centerPoint: halfSize};// Line Style Configuration   var lineStyleConfig = {  stroked: true,  filled: true,  opacity: 25,  strokeWidth: 0.2 // width in points  };// utility function for drawing a linefunction draw_line(x1, y1, x2, y2){      newPath = doc_ref.pathItems.add();   newPath.stroked = lineStyleConfig.stroked;  newPath.filled = lineStyleConfig.filled;  newPath.opacity = lineStyleConfig.opacity;  newPath.strokeWidth = lineStyleConfig.strokeWidth;  newPath.setEntirePath([[x1,-1*y1],[x2,-1*y2]]);}// here's where we actually draw the guillochevar guilloche = function(){	var	diff = guillocheOptions.majorR - guillocheOptions.minorR,			s = diff / guillocheOptions.minorR,			theta = 0,			radiusEffect = guillocheOptions.radiusEffectConstant + guillocheOptions.minorR,        			oldX, oldY;				for (var i = guillocheOptions.steps; i--;) {		var new_theta = guillocheOptions.angleMultiplier * theta,			  x = diff * Math.sin(new_theta) + radiusEffect * Math.sin(new_theta * s) + (guillocheOptions.centerPoint.x),			  y = diff * Math.cos(new_theta) - radiusEffect * Math.cos(new_theta * s) + (guillocheOptions.centerPoint.y);					theta += Math.PI * 4 / guillocheOptions.steps;				if (oldX)      draw_line(oldX, oldY, x, y);				oldX = x;		oldY = y;	}};// do itguilloche();